// Generated by CoffeeScript 1.12.6
(function() {
  var Poly, Rect, _Rectmethods, blocksatpoint, bottomof, boxtouchingwall, carveoutblock, closestpoint, halp, hitboxfilter, hitboxfilter_OLD, hslToRgb, hue2rgb, leftof, makebox, polygon_and_line_intersect, rightof, root, topof, xmlwrap;

  halp = {};

  hue2rgb = function(p, q, t) {
    if (t < 0) {
      t++;
    }
    if (t > 1) {
      t--;
    }
    if (t < 1 / 6) {
      return p + (q - p) * 6 * t;
    }
    if (t < 1 / 2) {
      return q;
    }
    if (t < 2 / 3) {
      return p + (q - p) * (2 / 3 - t) * 6;
    }
    return p;
  };

  hslToRgb = function(h, s, l) {
    var b, g, p, q, r;
    if (s === 0) {
      r = g = b = l;
    } else {
      q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      p = 2 * l - q;
      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1 / 3);
    }
    return [a, b, c].map(function(n) {
      return Math.round(n * 255);
    });
  };

  halp.color = {
    hslToRgb: hslToRgb
  };

  closestpoint = function(p, pointarr) {
    var closest, i, len, point;
    closest = pointarr[0];
    for (i = 0, len = pointarr.length; i < len; i++) {
      point = pointarr[i];
      if (closest.dist(p) > point.dist(p)) {
        closest = point;
      }
    }
    return closest;
  };

  polygon_and_line_intersect = function(candidate, line) {
    var edges, hits, p;
    p = new V2d(this.pos.x, this.pos.y);
    edges = pointlisttoedges(candidate.points);
    hits = edges.map(function(edg) {
      return line.lineintersect(edg);
    });
    hits = _.compact(hits);
    return hits;
  };

  Poly = (function() {
    function Poly(points) {
      this.points = points != null ? points : [];
    }

    return Poly;

  })();

  Poly.prototype.boundingbox = function() {
    var b, l, max, min, r, t, xs, ys;
    xs = this.points.map(function(pt) {
      return pt.x;
    });
    ys = this.points.map(function(pt) {
      return pt.y;
    });
    min = function(a, b) {
      return Math.min(a, b);
    };
    max = function(a, b) {
      return Math.max(a, b);
    };
    l = Math.round(xs.reduce(min));
    r = Math.round(xs.reduce(max));
    t = Math.round(ys.reduce(min));
    b = Math.round(ys.reduce(max));
    return makebox(V(l, t), V(r - l, b - t), V(0, 0));
  };

  Rect = (function() {
    function Rect(x, y, w1, h1) {
      this.x = x;
      this.y = y;
      this.w = w1;
      this.h = h1;
    }

    return Rect;

  })();

  Rect.prototype.relativetobox = function(anchor) {
    return V(this.x, this.y).vadd(V(this.w, this.h).vmul(anchor));
  };

  Rect.prototype.centerpoint = function() {
    return V(this.x + this.w / 2, this.y + this.h / 2);
  };

  _Rectmethods = {
    containspoint: function(p) {
      return this.x <= p.x && this.y <= p.y && this.x + this.w >= p.x && this.y + this.h >= p.y;
    }
  };

  _.extend(Rect.prototype, _Rectmethods);

  Rect.prototype.intersection = function(rectb) {
    var b, h, l, r, recta, t, w;
    recta = this;
    l = Math.max(recta.left(), rectb.left());
    t = Math.max(recta.top(), rectb.top());
    r = Math.min(recta.right(), rectb.right());
    b = Math.min(recta.bottom(), rectb.bottom());
    w = r - l;
    h = b - t;
    return new Rect(l, t, w, h);
  };

  Rect.prototype.strictoverlaps = function(rectb) {
    var recta;
    recta = this;
    if (recta.left() >= rectb.right() || recta.top() >= rectb.bottom() || recta.right() <= rectb.left() || recta.bottom() <= rectb.top()) {
      return false;
    } else {
      return true;
    }
  };

  Rect.prototype.overlaps = function(rectb) {
    var recta;
    recta = this;
    if (recta.left() > rectb.right() || recta.top() > rectb.bottom() || recta.right() < rectb.left() || recta.bottom() < rectb.top()) {
      return false;
    } else {
      return true;
    }
  };

  Rect.prototype.bonk = function() {
    return this.timers.bonk = 6;
  };

  Rect.prototype.tostone = function() {
    return DEPRECATE();
  };

  Rect.prototype.fixnegative = function() {
    if (this.w < 0) {
      this.x += this.w;
      this.w *= -1;
    }
    if (this.h < 0) {
      this.y += this.h;
      return this.h *= -1;
    }
  };

  hitboxfilter_OLD = function(hitbox, rectarray) {
    return rectarray.filter(function(box) {
      return hitbox.overlaps(box);
    });
  };

  hitboxfilter = function(hitbox, rectarray) {
    var res;
    stats.collisionchecks += rectarray.length;
    res = hitboxfilter_OLD(hitbox, rectarray);
    return res;
  };

  makebox = function(position, dimensions, anchor) {
    var truepos;
    truepos = position.vsub(dimensions.vmul(anchor));
    return new Rect(truepos.x, truepos.y, dimensions.x, dimensions.y);
  };

  leftof = function(box) {
    return box.x;
  };

  rightof = function(box) {
    return box.x + box.w;
  };

  bottomof = function(box) {
    return box.y + box.h;
  };

  topof = function(box) {
    return box.y;
  };

  Rect.prototype.left = function() {
    return leftof(this);
  };

  Rect.prototype.right = function() {
    return rightof(this);
  };

  Rect.prototype.bottom = function() {
    return bottomof(this);
  };

  Rect.prototype.top = function() {
    return topof(this);
  };

  Rect.prototype.issamebox = function(b) {
    return this.x === b.x && this.y === b.y && this.w === b.w && this.h === b.h;
  };

  blocksatpoint = function(blocks, p) {
    return blocks.filter(function(box) {
      return box.containspoint(p);
    });
  };

  boxtouchingwall = function(collidebox) {
    var block, blockcandidates, i, len, notontop;
    blockcandidates = hitboxfilter(collidebox, WORLD.bglayer);
    for (i = 0, len = blockcandidates.length; i < len; i++) {
      block = blockcandidates[i];
      notontop = collidebox.bottom() > block.top();
      if (notontop && collidebox.left() < block.left()) {
        return true;
      }
      if (notontop && collidebox.right() > block.right()) {
        return true;
      }
    }
    return false;
  };

  Rect.prototype.gethitbox = function() {
    return this;
  };

  carveoutblock = function(b) {
    var block, bloke, i, j, len, len1, results, tocarve, todelete;
    block = new Rect(b.x, b.y, b.w, b.h);
    tocarve = block.allstrictoverlaps();
    for (i = 0, len = tocarve.length; i < len; i++) {
      bloke = tocarve[i];
      blockcarve(bloke, block);
    }
    todelete = block.allstrictoverlaps();
    results = [];
    for (j = 0, len1 = todelete.length; j < len1; j++) {
      bloke = todelete[j];
      WORLD.bglayer = _.without(WORLD.bglayer, bloke);
      if (bloke._pixisprite != null) {
        results.push(stage.removeChild(bloke._pixisprite));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  Rect.prototype.allstrictoverlaps = function() {
    var blox;
    blox = WORLD.bglayer;
    return blox.filter((function(_this) {
      return function(otherblock) {
        return _this.strictoverlaps(otherblock);
      };
    })(this));
  };

  Rect.prototype.alloverlaps = function() {
    var blox;
    blox = WORLD.bglayer;
    return blox.filter((function(_this) {
      return function(otherblock) {
        return _this.overlaps(otherblock);
      };
    })(this));
  };

  Rect.prototype.equals = function(b) {
    return this.x = b.x && (this.y = b.y && (this.w = b.w && (this.h = b.h)));
  };

  halp.Rect = Rect;


  /*
    xml generation
   */

  xmlwrap = function(tagname, body) {
    return xmltag(tagname, void 0, body);
  };


  /*
  maketablerow = ( values ) ->
    tds = values.map (v) -> xmlwrap "td", v
    return xmlwrap "tr", tds
  jame.maketable = (arrofarr) ->
    domelm = $ '<table>'
    for k,v of arrofarr
      domelm.append maketablerow v
    return domelm
   */

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  root.halp = halp;

}).call(this);

//# sourceMappingURL=morehelpers.js.map
